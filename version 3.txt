# --------------------------------------------------- algorithm_handler.py -------------------------------------------------------------
from window import Window
from pygame import KEYDOWN, K_SPACE, K_1, K_2
from pygame.mouse import get_pressed as pyg_get_pressed
from pygame.mouse import get_pos as pyg_get_pos
from threading import Thread
from algorithms import BreadthFirstSearch, DijkstraUniformCostSearch
from snake import Snake
import cells
import numpy as np


class AlgorithmHandler(Window):

    def __init__(self):
        super().__init__()
        # Initailising Algorithms
        self.breadth = BreadthFirstSearch(
            self.grid, 
            *self.grid.fixed_cells # [start, end]
        )
        self.dijkstra = DijkstraUniformCostSearch(
            self.grid,
            *self.grid.fixed_cells # [start, end]
        )
        self.snake = Snake(self.grid, (10, 10))

    def handle_events(self, event):
        super().handle_events(event)
        mouse_pos = pyg_get_pos()
                    
        if event.type == KEYDOWN:
            if event.key == K_SPACE:
                self.grid.empty_path()
                self.breadth.restart(self.grid, *self.grid.fixed_cells)
                algorithm = Thread(target=self.breadth.run, daemon=True)
                algorithm.start()
            elif event.key == K_1:
                self.draw_type = cells.Contents.WALL
            elif event.key == K_2:
                self.draw_type = cells.Contents.FIELD

        elif pyg_get_pressed(5)[0]: # user drawing cells
            for x, y in np.ndindex(self.grid.shape): # iterating using np (gaming)
                if self.grid.get_cell(x, y).rect.collidepoint(mouse_pos):
                    self.grid.set_cell(x, y, self.draw_type)

        elif pyg_get_pressed(5)[2]: # user erasing cells
            for x, y in np.ndindex(self.grid.shape):
                if self.grid.get_cell(x, y).rect.collidepoint(mouse_pos):
                    self.grid.set_cell(x, y, cells.Contents.EMPTY)

# --------------------------------------------------- window.py -------------------------------------------------------------

# refactored game class
import cells, config, grid
import pygame
import sys
import numpy as np


class Window:
    def __init__(self):
        pygame.init()

        self.screen = pygame.display.set_mode(config.window_resolution.xy)
        self.clock = pygame.time.Clock()
        self.grid = grid.Grid(self)
        self.draw_type = "wall"
        self.running_algorithm = False

        pygame.display.set_caption("dipaly")

    def run(self):
        while True:
            self.clock.tick(120)
            for event in pygame.event.get():
                self.handle_events(event)
            self.draw()
            pygame.display.update()

    def handle_events(self, event):
        mouse_pos = pygame.mouse.get_pos()

        if event.type == pygame.QUIT: # you guessed it
            pygame.quit()
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_1:
                self.draw_type = "wall"
            elif event.key == pygame.K_2:
                self.draw_type = "field"

        elif pygame.mouse.get_pressed(5)[0]: # user drawing cells
            for x, y in np.ndindex(self.grid.shape): # iterating using np (gaming)
                if self.grid.get_cell(x, y).rect.collidepoint(mouse_pos):
                    self.grid.set_cell(x, y, cells.Contents.WALL if self.draw_type == "wall" else cells.Contents.FIELD)

        elif pygame.mouse.get_pressed(5)[2]: # user erasing cells
            for x, y in np.ndindex(self.grid.shape):
                if self.grid.get_cell(x, y).rect.collidepoint(mouse_pos):
                    self.grid.set_cell(x, y, cells.Contents.EMPTY)

    def draw(self):
        # background
        self.screen.fill(cells.Palette.LIGHTGREY)

        # drawing nodes
        for x, y in np.ndindex(self.grid.shape):
            cell = self.grid.get_cell(x, y)
            pygame.draw.rect(
                self.screen,
                cells.Palette.get_color(cell.cont),
                cell.rect,
                width = 1 if cell.cont == cells.Contents.EMPTY else 0 # border drawing stuff
            )
        self.draw_buttons()

    def draw_buttons(self):
        self.screen.blit(config.widgets.reset_button, (3, 3))

# --------------------------------------------------- grid.py -------------------------------------------------------------

import cells, config
import pygame
from random import randint
import numpy as np


class Grid:
    def __init__(self, window):
        # generating empty grid
        self.grid = np.full(config.grid_dimensions.xy, cells.Cell)
        self.empty_grid()
        self.shape = self.grid.shape
        self.window = window
        # generating fixed cells (start, end)
        self.fixed_cells = []
        self.gen_fixed_cells()

    def empty_grid(self): # setting all cells to empty and creating the rects
        rect_width, rect_height = (
            int(config.window_resolution.x/config.grid_dimensions.x),
            int(config.window_resolution.y/config.grid_dimensions.y)
        )

        for x, y in np.ndindex(self.grid.shape):
            # pygame.rect.Rect((position), (width/length))
            rect = pygame.rect.Rect(
                (x*rect_width, y*rect_height + config.settings.grid_buffer),
                (rect_width, rect_height)
            )
            self.grid[x, y] = cells.Cell(x, y, cells.Contents.EMPTY, rect)

    def gen_fixed_cells(self):
        self.fixed_cells = []
        fixed_cells_cont = (cells.Contents.START, cells.Contents.END)
        for fixed_cell_cont in fixed_cells_cont:
            rand_x, rand_y = (
                randint(0, config.grid_dimensions.x - 1),
                randint(0, config.grid_dimensions.y - 1)
            )
            self.grid[rand_x, rand_y].cont = fixed_cell_cont
            self.fixed_cells.append(self.grid[rand_x, rand_y])

    def set_cell(self, x, y, cont):
        if not self.grid[x, y].is_fixed():
            self.grid[x, y].cont = cont

    def get_cell(self, x, y):
        if 0 <= x < config.grid_dimensions.x and 0 <= y < config.grid_dimensions.y:
            return self.grid[x, y]
        return None


